from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import uvicorn
from database import initialize_db_pool, close_db_pool, execute_query
impor    try:
        print(f"ğŸ” [Bac        if result and len(result) > 0:
            created_company = result[0]
            company_id = created_company[0]  # First column is ID
            print(f"âœ… [Backend] Company successfully created in database with ID: {company_id}")
            print(f"ğŸ—‚ï¸ [Database] Table: pscdb.companies | Operation: INSERT | Row ID: {company_id}")
            
            # Return the created company in the expected format
            return {
                "id": str(company_id),
                "name": created_company[1],
                "address": created_company[4] or '',
                "phone": created_company[3] or '',
                "email": '',  # Not stored in DB but required by model
                "owner_email": created_company[2],
                "is_demo": created_company[6],
                "subscription_plan": created_company[5]
            } Writing to AWS PostgreSQL database 'pscdb.companies' table")
from datetime import datetime

app = FastAPI(title="PSC Accounting API", version="1.0.0")

# Initialize database connection on startup
@app.on_event("startup")
async def startup_event():
    print("ğŸš€ [Backend] Starting PSC Accounting API...")
    if initialize_db_pool():
        print("âœ… [Backend] Database connection established")
    else:
        print("âŒ [Backend] Failed to connect to database - API will not work properly")

@app.on_event("shutdown")
async def shutdown_event():
    print("ğŸ›‘ [Backend] Shutting down PSC Accounting API...")
    close_db_pool()

# Enable CORS for Flutter app
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify your Flutter app's origin
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic models
class Company(BaseModel):
    id: Optional[int] = None  # Changed from str to int to match database
    name: str
    email: str
    phone: Optional[str] = None
    address: Optional[str] = None
    subscription_plan: str = "free"
    owner_email: str
    is_demo: bool = False

class Invoice(BaseModel):
    id: Optional[int] = None
    company_id: str
    client_name: str
    amount: float
    date: str
    status: str = "pending"

class Expense(BaseModel):
    id: Optional[int] = None
    company_id: str
    description: str
    amount: float
    date: str
    category: str

class BankStatement(BaseModel):
    id: Optional[int] = None
    company_id: str
    transaction_date: str
    description: str
    amount: float
    balance: float

class Payslip(BaseModel):
    id: Optional[int] = None
    company_id: str
    employee_name: str
    month: str
    gross_salary: float
    net_salary: float
    status: str = "draft"

# Company endpoints

# In-memory storage (replace with database in production)
companies_db = [
    {
        "id": "demo-company-1",
        "name": "Demo Company Ltd",
        "email": "demo@example.com",
        "phone": None,
        "address": None,
        "subscription_plan": "free",
        "owner_email": "demo@example.com",
        "is_demo": True
    }
]

invoices_db = [
    {
        "id": 1,
        "company_id": "demo-company-1",
        "client_name": "ABC Corp",
        "amount": 1500.00,
        "date": "2024-07-15",
        "status": "paid"
    },
    {
        "id": 2,
        "company_id": "demo-company-1",
        "client_name": "XYZ Ltd",
        "amount": 2300.50,
        "date": "2024-07-20",
        "status": "pending"
    },
    {
        "id": 3,
        "company_id": "demo-company-1",
        "client_name": "Tech Solutions Inc",
        "amount": 850.75,
        "date": "2024-07-25",
        "status": "overdue"
    },
    {
        "id": 4,
        "company_id": "demo-company-1",
        "client_name": "Green Energy Co",
        "amount": 3200.00,
        "date": "2024-08-01",
        "status": "pending"
    },
    # Sample data for another company
    {
        "id": 5,
        "company_id": "created-12345",
        "client_name": "Sample Client",
        "amount": 750.00,
        "date": "2024-07-28",
        "status": "paid"
    }
]

expenses_db = [
    {
        "id": 1,
        "company_id": "demo-company-1",
        "description": "Office Supplies",
        "amount": 125.50,
        "date": "2024-07-10",
        "category": "Office"
    },
    {
        "id": 2,
        "company_id": "demo-company-1",
        "description": "Software License",
        "amount": 299.00,
        "date": "2024-07-12",
        "category": "Software"
    },
    {
        "id": 3,
        "company_id": "demo-company-1",
        "description": "Business Lunch",
        "amount": 75.25,
        "date": "2024-07-18",
        "category": "Meals"
    },
    {
        "id": 4,
        "company_id": "demo-company-1",
        "description": "Internet Service",
        "amount": 89.99,
        "date": "2024-08-01",
        "category": "Utilities"
    },
    # Sample data for another company
    {
        "id": 5,
        "company_id": "created-12345",
        "description": "Office Rent",
        "amount": 1200.00,
        "date": "2024-08-01",
        "category": "Office"
    }
]

payslips_db = [
    {
        "id": 1,
        "company_id": "demo-company-1",
        "employee_name": "John Doe",
        "month": "July 2024",
        "gross_salary": 5000.00,
        "net_salary": 4200.00,
        "status": "paid"
    },
    {
        "id": 2,
        "company_id": "demo-company-1",
        "employee_name": "Jane Smith",
        "month": "July 2024",
        "gross_salary": 4500.00,
        "net_salary": 3800.00,
        "status": "pending"
    },
    {
        "id": 3,
        "company_id": "demo-company-1",
        "employee_name": "Bob Johnson",
        "month": "June 2024",
        "gross_salary": 5200.00,
        "net_salary": 4350.00,
        "status": "paid"
    }
]

bank_statements_db = []

@app.get("/")
async def root():
    return {"message": "PSC Accounting API is running"}

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

# Company endpoints
@app.get("/companies")
async def get_companies(owner_email: Optional[str] = None):
    """Get companies owned by a user"""
    print(f"ğŸ¢ [Backend] Fetching companies for owner_email: {owner_email}")
    
    try:
        if owner_email:
            query = "SELECT * FROM companies WHERE owner_email = %s ORDER BY created_at DESC"
            companies = execute_query(query, (owner_email,), fetch=True)
            print(f"ğŸ” [Backend] Found {len(companies)} companies for {owner_email} in AWS database")
            print(f"ğŸ“‹ [Backend] Companies: {[c.get('name', 'Unknown') for c in companies]}")
        else:
            query = "SELECT * FROM companies ORDER BY created_at DESC"
            companies = execute_query(query, fetch=True)
            print(f"ğŸ“‹ [Backend] Returning all {len(companies)} companies from AWS database")
        
        return companies
    except Exception as e:
        print(f"âŒ [Backend] Database error fetching companies: {e}")
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")

@app.post("/companies", response_model=Company)
async def create_company(company: Company):
    """Create a new company"""
    print(f"ğŸ¢ [Backend] Creating company with data: {company.dict()}")
    
    try:
        # Generate UUID for the company
        company_id = str(uuid.uuid4())
        
        print(f"ğŸ“‹ [Backend] Generated company ID: {company_id}")
        print(f"ï¿½ [Backend] Writing to AWS PostgreSQL database 'pscdb.companies' table")
        
        # Insert into database - using actual database schema
        query = """
            INSERT INTO companies (name, slug, owner_email, phone, address, subscription_plan, is_demo, status, created_at) 
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING *
        """
        
        # Generate slug from name (replace spaces with hyphens, lowercase)
        slug = company.name.lower().replace(' ', '-').replace('_', '-')
        
        params = (
            company.name,
            slug,
            company.owner_email,
            company.phone or '',
            company.address or '',
            'free',  # default subscription plan
            company.is_demo if hasattr(company, 'is_demo') else False,
            'active',  # default status
            datetime.now()
        )
        
        result = execute_query(query, params, fetch=True)
        
        if result and len(result) > 0:
            created_company = result[0]
            print(f"âœ… [Backend] Company successfully created in database with ID: {company_id}")
            print(f"ï¿½ï¸ [Database] Table: pscdb.companies | Operation: INSERT | Row ID: {company_id}")
            return created_company
        else:
            raise Exception("Failed to create company - no result returned")
            
    except Exception as e:
        print(f"âŒ [Backend] Database error creating company: {e}")
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")

@app.get("/companies/{company_id}")
async def get_company(company_id: str):
    """Get a specific company by ID"""
    print(f"ğŸ¢ [Backend] Fetching company with ID: {company_id}")
    
    try:
        query = "SELECT * FROM companies WHERE id = %s"
        result = execute_query(query, (company_id,), fetch=True)
        
        if result and len(result) > 0:
            company = result[0]
            print(f"âœ… [Backend] Found company: {company.get('name', 'Unknown')}")
            return company
        else:
            print(f"âŒ [Backend] Company not found with ID: {company_id}")
            raise HTTPException(status_code=404, detail="Company not found")
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"âŒ [Backend] Database error fetching company: {e}")
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")

# Invoice endpoints
@app.get("/invoices", response_model=List[Invoice])
async def get_invoices(company_id: Optional[str] = None):
    if company_id:
        return [invoice for invoice in invoices_db if invoice.get("company_id") == company_id]
    return invoices_db

@app.post("/invoices", response_model=Invoice)
async def create_invoice(invoice: Invoice):
    print(f"ğŸ“„ [Backend] Creating invoice with data: {invoice.dict()}")
    
    invoice.id = max([i.get("id", 0) for i in invoices_db], default=0) + 1
    invoice_dict = invoice.dict()
    
    print(f"ğŸ“‹ [Backend] Generated invoice ID: {invoice.id}")
    print(f"âš ï¸ [Backend] WARNING: Using IN-MEMORY storage for invoices - data will be lost on server restart!")
    print(f"ğŸ“Š [Backend] Current invoices_db before insert: {len(invoices_db)} invoices")
    print(f"ğŸ¢ [Backend] Invoice company_id: {invoice.company_id}")
    print(f"ğŸ’¾ [Backend] TODO: Should write to MySQL/PostgreSQL invoices table with company_id foreign key")
    
    invoices_db.append(invoice_dict)
    
    print(f"âœ… [Backend] Invoice added to in-memory storage")
    print(f"ğŸ“Š [Backend] Current invoices_db after insert: {len(invoices_db)} invoices")
    
    return invoice

@app.get("/invoices/{invoice_id}", response_model=Invoice)
async def get_invoice(invoice_id: int):
    for invoice in invoices_db:
        if invoice.get("id") == invoice_id:
            return invoice
    raise HTTPException(status_code=404, detail="Invoice not found")

@app.put("/invoices/{invoice_id}", response_model=Invoice)
async def update_invoice(invoice_id: int, invoice: Invoice):
    for i, existing_invoice in enumerate(invoices_db):
        if existing_invoice.get("id") == invoice_id:
            invoice.id = invoice_id
            invoices_db[i] = invoice.dict()
            return invoice
    raise HTTPException(status_code=404, detail="Invoice not found")

@app.delete("/invoices/{invoice_id}")
async def delete_invoice(invoice_id: int):
    for i, invoice in enumerate(invoices_db):
        if invoice.get("id") == invoice_id:
            del invoices_db[i]
            return {"message": "Invoice deleted"}
    raise HTTPException(status_code=404, detail="Invoice not found")

# Expense endpoints
@app.get("/expenses", response_model=List[Expense])
async def get_expenses(company_id: Optional[str] = None):
    if company_id:
        return [expense for expense in expenses_db if expense.get("company_id") == company_id]
    return expenses_db

@app.post("/expenses", response_model=Expense)
async def create_expense(expense: Expense):
    print(f"ğŸ’° [Backend] Creating expense with data: {expense.dict()}")
    
    expense.id = max([e.get("id", 0) for e in expenses_db], default=0) + 1
    expense_dict = expense.dict()
    
    print(f"ğŸ“‹ [Backend] Generated expense ID: {expense.id}")
    print(f"âš ï¸ [Backend] WARNING: Using IN-MEMORY storage for expenses - data will be lost on server restart!")
    print(f"ğŸ“Š [Backend] Current expenses_db before insert: {len(expenses_db)} expenses")
    print(f"ğŸ¢ [Backend] Expense company_id: {expense.company_id}")
    print(f"ğŸ’¾ [Backend] TODO: Should write to MySQL/PostgreSQL expenses table with company_id foreign key")
    
    expenses_db.append(expense_dict)
    
    print(f"âœ… [Backend] Expense added to in-memory storage")
    print(f"ğŸ“Š [Backend] Current expenses_db after insert: {len(expenses_db)} expenses")
    
    return expense

@app.get("/expenses/{expense_id}", response_model=Expense)
async def get_expense(expense_id: int):
    for expense in expenses_db:
        if expense.get("id") == expense_id:
            return expense
    raise HTTPException(status_code=404, detail="Expense not found")

@app.put("/expenses/{expense_id}", response_model=Expense)
async def update_expense(expense_id: int, expense: Expense):
    for i, existing_expense in enumerate(expenses_db):
        if existing_expense.get("id") == expense_id:
            expense.id = expense_id
            expenses_db[i] = expense.dict()
            return expense
    raise HTTPException(status_code=404, detail="Expense not found")

@app.delete("/expenses/{expense_id}")
async def delete_expense(expense_id: int):
    for i, expense in enumerate(expenses_db):
        if expense.get("id") == expense_id:
            del expenses_db[i]
            return {"message": "Expense deleted"}
    raise HTTPException(status_code=404, detail="Expense not found")

# Payslips endpoints
@app.get("/payslips", response_model=List[Payslip])
async def get_payslips(company_id: Optional[str] = None):
    if company_id:
        return [payslip for payslip in payslips_db if payslip.get("company_id") == company_id]
    return payslips_db

@app.post("/payslips", response_model=Payslip)
async def create_payslip(payslip: Payslip):
    print(f"ğŸ’¼ [Backend] Creating payslip with data: {payslip.dict()}")
    
    payslip.id = max([p.get("id", 0) for p in payslips_db], default=0) + 1
    payslip_dict = payslip.dict()
    
    print(f"ğŸ“‹ [Backend] Generated payslip ID: {payslip.id}")
    print(f"âš ï¸ [Backend] WARNING: Using IN-MEMORY storage for payslips - data will be lost on server restart!")
    print(f"ğŸ“Š [Backend] Current payslips_db before insert: {len(payslips_db)} payslips")
    print(f"ğŸ¢ [Backend] Payslip company_id: {payslip.company_id}")
    print(f"ğŸ’¾ [Backend] TODO: Should write to MySQL/PostgreSQL payslips table with company_id foreign key")
    
    payslips_db.append(payslip_dict)
    
    print(f"âœ… [Backend] Payslip added to in-memory storage")
    print(f"ğŸ“Š [Backend] Current payslips_db after insert: {len(payslips_db)} payslips")
    
    return payslip

@app.get("/payslips/{payslip_id}", response_model=Payslip)
async def get_payslip(payslip_id: int):
    for payslip in payslips_db:
        if payslip.get("id") == payslip_id:
            return payslip
    raise HTTPException(status_code=404, detail="Payslip not found")

@app.put("/payslips/{payslip_id}", response_model=Payslip)
async def update_payslip(payslip_id: int, payslip: Payslip):
    for i, existing_payslip in enumerate(payslips_db):
        if existing_payslip.get("id") == payslip_id:
            payslip.id = payslip_id
            payslips_db[i] = payslip.dict()
            return payslip
    raise HTTPException(status_code=404, detail="Payslip not found")

@app.delete("/payslips/{payslip_id}")
async def delete_payslip(payslip_id: int):
    for i, payslip in enumerate(payslips_db):
        if payslip.get("id") == payslip_id:
            del payslips_db[i]
            return {"message": "Payslip deleted"}
    raise HTTPException(status_code=404, detail="Payslip not found")

# Bank statement endpoints
@app.get("/bank-statements", response_model=List[BankStatement])
async def get_bank_statements(company_id: Optional[str] = None):
    if company_id:
        return [statement for statement in bank_statements_db if statement.get("company_id") == company_id]
    return bank_statements_db

@app.post("/bank-statements", response_model=BankStatement)
async def create_bank_statement(statement: BankStatement):
    statement.id = max([s.get("id", 0) for s in bank_statements_db], default=0) + 1
    statement_dict = statement.dict()
    bank_statements_db.append(statement_dict)
    return statement
    return statement

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
